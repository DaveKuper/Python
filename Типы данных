Типы данных:
Переменная (англ. Variable) - это идентификатор, который указывает на определенную область памяти, 
где хранятся произвольные данные - созданный объект (значение переменной).

В Python встроенные типы данных подразделяются на 2 группы:

Скалярные (неделимые).

Числа (целое, вещественное).
Логический тип.
NoneType.
Структурированные (составные) / коллекции.

Последовательности: строка, список, кортеж, числовой диапазон.
Множества.
Отображения: словарь.

Кроме того, все объекты в Python относятся к одной из 2-х категорий:

Мутирующие (англ. Mutable): содержимое объекта можно изменить после создания (например, список);
Немутирующие (англ. Immutable): содержимое объекта нельзя изменить после создания (например, строка или число).

3.1.3. Коллекции
Используя скалярные типы можно столкнуться с проблемой - что делать, если необходимо хранить и обрабатывать набор таких значений?. Для этого в Python предназначены специальные типы - коллекции.

Коллекции — это группа типов данных, которые содержат в себе другие данные и поддерживают:

проверку на вхождения элементов in и not in (True/False);
определение размера len();
возможность выполнения итераций (перемещения по элементам последовательности) - из-за этого коллекции также называются итерируемыми объектами (подробнее рассматриваются в Теме №4).
Среди коллекций выделяют 3 группы:

последовательности: строка, список, кортеж, числовой диапазон;
множества;
отображения: словарь.
3.1.3.1. Последовательности
Последовательность - это упорядоченная коллекция, поддерживающая индексированный доступ к элементам.

Некоторые последовательности в Python в отличие от традиционных массивов (например, в Паскале или Си) могут хранить элементы различного типа (в том числе и коллекции различных видов).

В языке Python имеется пять встроенных типов последовательностей (Таблица 3.1.1).

Далее подробно рассматриваются объекты str, list, tuple и range.
Некоторые операции справедливы для всех последовательностей (за исключением случаев, где они не возможны исходя из определения типа).

Ниже используются следующие обозначения:

s и t: последовательности одного типа;
n, k, start, end, step: целые числа;
x: произвольный объект, отвечающий критериям соответствующего вызова функции.
Длина
len(s)
Функция len() возвращает длину (количество элементов в последовательности) s.

Конкатенация («склеивание»)
s + t
Возвращает новый объект - «склейку» s и t.

Дублирование
s * n n * s
Возвращает последовательность, повторяющуюся n раз.

Индексация и срезы
Получить доступ к отдельному или группе элементов последовательности возможно с помощью оператора []. Индексацию (получение отдельного элемента) можно считать частным случаем получения среза (слайсинга).

Оператор получения среза имеет три формы записи:

s[start] s[start:end] s[start:end:step]
s[start]: индексация (с 0);
s[start:end]: срез [start; end);
s[start:end:step]: срез [start; end) c шагом step.
В ряде случаев целочисленные параметры start, end и step могут быть опущены. Элемент с индексом end не включается в результат при взятии срезов.

Минимальное и максимальное значения
min(s) max(s)
Возвращает минимальный и максимальный элементы последовательности s соответственно.

Проверка на вхождение
x in s
Возвращает True, если x входит в последовательность s и False в противном случае.

Индекс (положение) элемента
s.index(x[, start[, end]]) --> int
Возвращает первое вхождение элемента x в последовательность s (между индексами start и end, если они заданы).

Количество повторений
s.count(x)
Возвращает количество вхождений элементов x в последовательность s.

Сортировка
sorted(iterable, key=None, reverse=False)
Возвращает отсортированный объект в виде списка. Исходный объект при этом не изменяется.

Параметры:	
key – функция сортировки (по умолчанию не учитывается, сортировка осуществляется поэлементно);
reverse – если равен True, сортировка осуществляется в обратном порядке.
В Листинге 3.1.6 приведен пример выполнения указанных операций на примере последовательности «Список». Выполнение срезов отдельно рассматривается на примере строк ниже.

Листинг 3.1.6 - Общие операции для последовательностей¶
>>> s = [1, 2, 3]  # Список из 3-х целых чисел

>>> len(s)
3

>>> 1 in s
True
>>> 5 in s
False

>>> s += [5, 6]
>>> s
[1, 2, 3, 5, 6]

>>> s *= 2
>>> s
[1, 2, 3, 5, 6, 1, 2, 3, 5, 6]

>>> min(s), max(s)
(1, 6)

>>> s.index(5)
3

>>> s.count(4)
0

>>> sorted(s)
[1, 1, 2, 2, 3, 3, 5, 5, 6, 6]


3.1.3.1.2. Строка
Строка (str) - это упорядоченная неизменяемая последовательность символов Юникода.

class str(object='') class str(object=b'', encoding='utf-8', errors='strict')
Конструктор класса str.

Литералы строк создаются с использованием кавычек или апострофов, при этом важно, чтобы с обоих концов литерала использовались кавычки одного и того же типа. В дополнение к можно использовать строки в тройных кавычках, то есть строки, которые начинаются и заканчиваются тремя символами кавычки (либо тремя кавычками, либо тремя апострофами).

Важным для строкового типа является понятие кодировки символов, что в частности, влияет на правила сравнения строк. По умолчанию Python хранит строки в кодировке UTF-8.

Если в строке необходимо использовать специальные символы (например, перенос или одноименные кавычки), можно воспользоваться механизмом экранирования символов, для чего используется специальный символ \. В Таблице 3.1.2 приведены некоторые из экранированных последовательностей.

Таблица 3.1.2 - Экранированные последовательности в Python¶
Последовательность	Значение
\\	Обратный слеш (\)
\'	Апостроф (')
\"	Кавычка (")
\n	Символ «Перевод строки»
\t	Символ «Табуляция»
Пример создания строковых литералов приведен в Листинге 3.1.7, базовые операции - в Листинге 3.1.8.

Листинг 3.1.7 - Создание строк¶
# Запись строковых литералов
"Простой текст в кавычках"

'Текст в апострофах'

"""А это текст, который занимает 2 строки
(в данном случае использовать три апострофа не рекомендуется)"""

# Экранированные последовательности начинаются с символа \
"Текст, который содержит \"текст в кавычках\""
'Текст, который содержит \'текст в апострофах\''
"Если внутри кавычки другого типа, можно не 'экранировать'"

"Так в строке будет табуляция\tи\nперенос, а также обратный слеш \\"

# "Отключить" экранирование можно указав, что строка является "сырой"
r"Так в строке не будет табуляция\tи\nпереноса, но будет 2 обратных слеша \\"
Листинг 3.1.8 - Операции над строковым типом¶
# 1. Арифметические операции
#    Тип результата операции определяется типом аргументов

# s1 + s2
# Соединяет строки s1 и s2
>>> "Py" + "thon"
'Python'
# или просто написать рядом
>>> "Py" "thon"
'Python'

# s1 * n
# Составляет строку из n повторений строки s1
>>> "па" * 2
'папа'

# 2. Равенство и сравнение
#    Результат логического типа
#
#    Операции сравнения выполняются посимвольно слева направо с учетом кодировки.
#    Ознакомиться с таблицей символов Юникода рекомендуется на ресурсе
#    http://unicode-table.com/.

# s1 == s2, s1 != s2
# Проверка строк на равенство/неравенство
>>> "текст1" == "текст2"
False
>>> "текст1" != "текст2"
True

# x > y, x < y, x >= y, x <= y
# Больше, меньше, больше или равно, меньше или равно
>>> "текст1" > "текст2"
False
>>> "текст1" <= "текст2"
True

# Возможно составление цепочек сравнений
>>> "текст1" < "текст12" <= "текст2"
True

# s1 in s2
# Проверка вхождения строки s1 в s2
>>> "p" in "Python"
False

3.1.3.1.2.1. Характерные операции
Строки поддерживают все общие операции для последовательностей, и имеют ряд дополнительных методов.

chr(i)
Возвращает символ № i из таблицы Unicode.

ord(c)
Возвращает номер символа c из таблицы Unicode.

class str
Пусть s - строка, на которой вызывается метод.

upper()
Возвращает копию строки s в верхнем регистре.

lower()
Возвращает копию строки s в нижнем регистре.

capitalize()
Возвращает копию строки с первым символом в верхнем регистре.

title()
Возвращает копию строки, в которой первые символы каждого слова преобразованы в верхний регистр, а все остальные - в нижний регистр.

count(t[, start[, end]])
Возвращает число вхождений строки t в строку s (или в срез s[start:end]).

find(t[, start[, end]])
Возвращает позицию самого первого (крайнего слева) вхождения подстроки t в строку s (или в срез s[start:end]); если подстрока t не найдена, возвращается -1.

index(t[, start[, end]])
Аналогично str.find(), но генерируется исключение ValueError, если подстрока не найдена.

replace(old, new[, count])
Возвращает копию строки s, в которой каждое (но не более count, если этот аргумент определен) вхождение подстроки old замещается подстрокой new.

split(sep=None, maxsplit=-1)
Возвращает список строк, разбитых по строке sep.

join(seq)
Возвращает строку-«склейку» элементов seq, используя s в качестве разделителя.

Пример использования строковых методов приведен в Листинге 3.1.10.

Листинг 3.1.10 - Использование строковых методов¶
>>> s = "ЭТО просТо ТеКст"

>>> ord(s[0])
1069
>>> chr(1069)
'р'

>>> s.upper(), s.lower(), s.title(), s.capitalize()
('ЭТО ПРОСТО ТЕКСТ', 'это просто текст', 'Это Просто Текст', 'Это просто текст')

>>> s.find("Т")
1

>>> s.replace("Т", "т")
'ЭтО просто теКст'

>>> lst = s.split()
>>> lst
['ЭТО', 'просТо', 'ТеКст']

>>> "-".join(lst)
'ЭТО-просТо-ТеКст'
3.1.3.1.3.1. Характерные операции
Списки поддерживают все общие операции для последовательностей, и имеют ряд дополнительных методов.

class list
Пусть lst - список, на котором вызывается метод.

append(x)
Добавляет элемент x в конец списка lst.

extend(m) lst += m
Добавляет в конец списка lst все элементы коллекции m.

insert(i, x)
Вставляет элемент х в список lst в позицию i.

remove(x)
Удаляет из списка lst первый элемент со значением x.

pop([i])
Возвращает последний или i-й элемент, удаляя его из последовательности.

clear()
Удаляет из списка lst все элементы (очищает список).

sort(*, key=None, reverse=None)
Выполняет сортировку списка lst. Отличается от функции sorted() тем, что сортирует исходный объект, а не возвращает новый.

Параметры:	
key – функция сортировки (по умолчанию не учитывается, сортировка осуществляется поэлементно);
reverse – если равен True, сортировка осуществляется в обратном порядке.
reverse()
Переворачивает элементы списка lst.

del lst[i[:j]]
Удаляет из списка lst элемент с индексом i (или несколько элементов, если задан индекс j).

В Листинге 3.1.13 приведен пример использования методов списков.

Листинг 3.1.13 - Работа со списками¶
# 1. Методы списка

>>> a = [8, 7, 5.5, 1000, 3.50, 200]

>>> a[0] = 7
>>> a
[7, 7, 5.5, 1000, 3.50, 200]

>>> a.index(7)
0

>>> a.count(7)
2

>>> a.insert(2, 1000)
>>> a
[7, 7, 1000, 5.5, 1000, 3.5, 200]

>>> a.append(5.5)
>>> a
[7, 7, 1000, 5.5, 1000, 3.5, 200, 5.5]

>>> a += [0, 0]
>>> a
[7, 7, 1000, 5.5, 1000, 3.5, 200, 5.5, 0, 0]

>>> b = a.pop()
>>> b
0
>>> a
[7, 7, 1000, 5.5, 1000, 3.5, 200, 5.5, 0]

>>> a.sort()
>>> a
[0, 3.5, 5.5, 5.5, 7, 7, 200, 1000, 1000]

>>> a.remove(1000)
>>> a
[0, 3.5, 5.5, 5.5, 7, 7, 200, 1000]

>>> del a[2:4]
>>> a
[0, 3.5, 7, 7, 200, 1000]

>>> a.reverse()
>>> a
[1000, 200, 7, 7, 3.5, 0]

# 2. Сравнения и равенство
# Простое сравнение
>>> a = [1, 5, 10]
>>> b = [1, 5, 10]
>>> a == b
True

>>> b[0] = 5
>>> b
[5, 5, 10]
>>> a < b
True

# Вложенное сравнение
>>> a[0] = [3, "aaa"]
>>> b[0] = [3, "bb"]
>>> a, b
([[3, 'aaa'], 5, 10], [[3, 'bb'], 5, 10])
>>> a < b
True

3.1.3.1.4. Кортеж
Кортеж (tuple) - это упорядоченная неизменяемая последовательность элементов.

Особенности: умеет все, что умеет список, за исключением операций, приводящих к изменению кортежа. Применяется в случаях, когда известно, что последовательность не будет меняться после создания.

class tuple([iterable])
Конструктор класса tuple.

Создать кортеж можно несколькими способами (Листинге 3.1.14).

Листинг 3.1.14 - Создание кортежа¶
# 1. Пустой кортеж создается с помощью пустых круглых скобок или функции tuple()
>>> ()
()
>>> tuple()
()

# 2. Инициализировать кортеж элементами можно одним из следующих способов:
>>> 1,
(1,)
>>> 1, 2, "text"
(1, 2, 'text')
>>> s = tuple("text")
>>> s
('t', 'e', 'x', 't')
>>>

# 3. Т.к. структура является неизменяемой, изменение содержимого запрещено
>>> s[0] = "n"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
Кортежи поддерживают все операции, общие для последовательностей.

3.1.3.2.1. Общие операции
Списки поддерживают все общие операции для последовательностей, и имеют ряд дополнительных методов. Операции, приводящие к изменению объекта, доступны только для set.

class set
Пусть st - множество, на котором вызывается метод.

add(elem)
Добавляем элемент elem в множество st.

remove(elem)
Удаляет элемент elem из множества st. Если элемент не находится в множестве, возникает ошибка.

discard(elem)
Удаляет элемент elem из множества st, если он присутствует в множестве.

pop(elem)
Удаляет элемент elem из множества st и возвращает в качестве результата.

clear()
Удаляет все элементы из множества.

3.1.3.2.2. Математические операции
Множества поддерживают математические операции, характерные для множеств (пересечение, объединение и др.), некоторые из которые приведены ниже.

class set
Пусть st - множество, на котором вызывается метод.

union(other, ...) st | other | ...
Возвращает новое множество - объединение множеств st и other.

intersection(other, ...) st & other & ...
Возвращает новое множество - пересечение множеств st и other.

difference(other, ...) st - other - ...
Возвращает новое множество - разность множеств st и other.

isdisjoint(other)
Возвращает True если st не содержит общий элементов с other.

issubset(other) st <= other
Возвращает True если все элементы st содержатся в other.

st < other
Аналогично st <= other, но множества не должны полностью совпадать.

issuperset(other) st >= other
Возвращает True если все элементы other содержатся в st.

st > other
Аналогично st >= other, но множества не должны полностью совпадать.

update(other, ...) st |= other | ...
Добавляет элементы из other в st.

В Листинге 3.1.17 приведен пример работы с множеством.

Листинг 3.1.17 - Пример работы с множеством¶
>>> a = {2, 4, 6, 8, 10}
>>> b = set(range(11))

>>> a
{8, 10, 2, 4, 6}
>>> b
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
>>>

>>> b.remove(0)
>>> b
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

>>> a.add(12)
>>> a
{2, 4, 6, 8, 10, 12}

>>> a & b
{8, 2, 10, 4, 6}

>>> a | b
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12}

>>> a - b
{12}

>>> b - a
{1, 9, 3, 5, 7}

3.1.3.3. Отображения
Отображение - это неупорядоченная коллекция пар элементов «ключ-значение». В разных языках синонимом отображений являются термины словарь, хеш-таблица или ассоциативный массив.

Отображения в Python представлены единственным типом dict (словарь), в котором в качестве ключа может выступать любой хешируемый объект, а в качестве значения - произвольный объект.

class dict(**kwarg) class dict(mapping, **kwarg) class dict(iterable, **kwarg)
Конструкторы класса dict.

Создать словарь можно несколькими способами (Листинг 3.1.18).

Листинг 3.1.18 - Создание словаря¶
# 1. Пустой словарь создается с помощью {} или функции dict()
>>> {}
{}
>>> dict()
{}

# 2. Инициализировать словарь элементами, используя:
#    - фигурные скобки с перечислением элементов в виде 'ключ: значение';
#    - функцию dict(), передав набор пар 'ключ: значение'.
#    Следует обратить внимание, что т.к. множество - неупорядоченный набор данных,
#    при выводе порядок его элементов может быть произвольным.
>>> {"one": 1, "two": 2, "three": 3}
{'two': 2, 'one': 1, 'three': 3}
>>> dict(one=1, two=2, three=3)
{'two': 2, 'one': 1, 'three': 3}
Ниже рассмотрены операции, доступные для словарей.

class dict
Пусть d - словарь, на котором вызывается метод.

d[key]
Возвращает значение словаря для ключа key. Если ключ не существует, возникает ошибка.

get(key[, default])
Возвращает значение словаря для ключа key. Если ключ не существует возвращается значение default или None.

d[key] = value
Устанавливает значение словаря по ключу key. Если ключ не существует, он создается.

items()
Возвращает набор пар «ключ-значение» для словаря d.

keys()
Возвращает набор ключей для словаря d.

values()
Возвращает набор значений для словаря d.

clear()
Удаляет из словаря все элементы.

del d[key]
Удаляет пару «ключ-значение» на основании ключа key.

В Листинге 3.1.19 приведен пример работы со словарем.

Листинг 3.1.19 - Пример работы со словарем¶
>>> phonebook = {"Петров Петр": "+79102222222"}
>>> phonebook["Иванов Сергей"] = "+79101111111"
>>> phonebook
{'Иванов Сергей': '+79101111111', 'Петров Петр': '+79102222222'}

>>> phonebook["Петров Петр"]
'+79102222222'

# Обновили номер телефона
>>> phonebook["Петров Петр"] = "+79103333333"
>>> phonebook
{'Иванов Сергей': '+79101111111', 'Петров Петр': '+79103333333'}

>>> "Васильев Василий" in phonebook
False

>>> phonebook.get("Васильев Василий", "Номер не найден")
'Номер не найден'

>>> phonebook.keys()
dict_keys(['Иванов Сергей', 'Петров Петр'])
>>> phonebook.values()
dict_values(['+79101111111', '+79103333333'])


def min_of_cubes(x, y):

    # Идентификаторы 'x' и 'y' являются:
    # - локальными для sum_of_cubes()
    # - нелокальными для cube()

    def cube(a):
        return a**3  # 'a' - локальный идентификатор функции cube()

    return min(cube(x), cube(y), cube(c))  # Функция min() находится
                                           # во встроенной области
                                           # видимости и видна везде

# Идентификаторы 'a', 'b' и 'c' имеют глобальную область видимости
a, b, c = 2, 3, 4
print(min_of_cubes(a, b))  # 8
